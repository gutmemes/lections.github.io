<?php 

include('index.php');
    
?>

    <div class="lections">
    <h1 id="usesql">Применение языка SQL</h1>
    <h2 id="usesql">Подключение к СУБД</h2>
    <p>Перед тем как перейти к более подробному изучению операторов языка SQL, рассмотрим возможный сценарий работы пользователя с СУБД.

Первым шагом в любом случае следует выполнить подключение к СУБД. Например, CONNECT TO MyDB1 USER User1/Password1;.

Фраза TO специфицирует источник данных, с которым устанавливается соединение. Фраза USER определяет имя и пароль пользователя, который будет работать с базой данных.

Операторы и функции языка SQL не чувствительны к регистру, в отличие от строковых значений. Однако, как и в стандарте языка, SQL-операторы всегда будут обозначаться в лекциях заглавными буквами, а названия полей, таблиц и псевдонимов (алиасов) - строчными.

Перед началом работы с данными должны быть выполнены следующие действия:</p>
<ul>
    
    <li>разработана модель базы данных и на ее основании создана схема базы данных - все взаимосвязанные таблицы;</li>
    <li>в каждую созданную таблицу должны быть введены данные.</li>

</ul>
<h1 id="create_table">Создание таблицы</h1>
<p>Для создания таблицы используется оператор CREATE TABLE , имеющий в стандарте SQL92 следующее формальное описание:

CREATE [ [ { GLOBAL | LOCAL } ] TEMPORARY] 
    TABLE имя_таблицы
    ( { column | [table_constraint] } . , .. 
    [ ON COMMIT { DELETE | PRESERVE} ROWS ] );

column определяется как

имя_поля {domain | datatype [size]}
    [column_constraint:]
    [ DEFAULT default_value ]
    [ COLLATE collate_value ]

Фразы GLOBAL TEMPORARY или LOCAL TEMPORARY указывают на создание временной таблицы.

Фраза ON COMMIT может быть указана только для временных таблиц. По умолчанию для временных таблиц подразумевается фраза ON COMMIT DELETE ROWS.

После имени таблицы в круглых скобках через запятую указывается список полей (называемых также столбцами) и ограничений. Каждое поле имеет имя и тип (datatype). Тип может быть определен как любой допустимый тип языка SQL или как домен. Например, язык SQL допускает такие типы как : integer, char (число_символов), varchar (число_символов), int, smallint, float, date.

Фраза DEFAULT определяет значение по умолчанию. Это значение имеет более высокий приоритет, чем значение по умолчанию, указанное в домене (если вместо типа данных используется домен).

Ограничения для таблицы ( table_constraint ) и ограничения для столбца ( column_constraint ), называемые также ограничениями целостности, накладывают определенные условия на вводимые в таблицу данные.

Ограничения для столбца указываются непосредственно после описания столбца, а ограничения для таблицы - через запятую после описания любого столбца.

В стандарте SQL92 ограничения должны иметь имена, которые генерируются СУБД. В наиболее продвинутых БД, в частности Oracle, доступ к ограничениям возможен посредством служебных таблиц словаря базы данных и дополнительного набора команд языка SQL.

Ограничения для столбца могут указываться следующими фразами:</p>
<p>Ограничения для столбца могут указываться следующими фразами:</p>
<ul>
    <li>NOT NULL - в любой добавляемой или изменяемой строке столбец всегда должен иметь значение, отличное от NULL .</li>
    <li>UNIQUE - все значения столбца должны быть уникальны.</li>
    PRIMARY KEY - устанавливает один столбец как первичный ключ и одновременно подразумевает, что все значения столбца будут уникальны.</li>
    <li>CHECK ( condition ) - указываемое в скобках условие использует для сравнения значение столбца и возвращает TRUE, FALSE или UNKNOWN. Если при попытке выполнения SQL-оператора возвращаемое значение равно FALSE, то оператор выполнен не будет.</li>
    <li>REFERENCES table ( fields_list ) - ограничение требует совпадения значений столбцов данной таблицы с указанными столбцами родительской таблицы.</li>
</ul>
<p>Ограничения для таблицы могут указываться следующими фразами:</p>
<ul>
    <li>CHECK ( condition ) - указываемое в скобках условие использует для сравнения значение столбца и возвращает TRUE, FALSE или UNKNOWN. Если при попытке выполнения SQL-оператора возвращаемое значение равно FALSE, то оператор выполнен не будет.</li>
    FOREIGN KEY ( fields_list ) - это ограничение по внешнему ключу аналогично ограничению <li>REFERENCES для столбцов и гарантирует, что все значения, указанные во внешнем ключе, будут соответствовать значениям родительского ключа, обеспечивая ссылочную целостность. Следует отметить, что типы данных столбцов, используемых в этом ограничении, должны совпадать, а типы таблиц (постоянная базовая таблица, глобальная временная таблица, локальная временная таблица) родительского и внешнего ключа - соответствовать друг другу.</li>
</ul>
<p>Стандарт SQL92 позволяет устанавливать режим контроля ограничений как перед выполнением каждого SQL-оператора, так и в конце текущей транзакции. В последнем случае допускается нарушение ограничения целостности внутри транзакции. Этот режим очень полезен для внесения данных в таблицы, связанные ограничением REFERENCES .</p>
<h1 id="for_table">Определение ограничений для таблицы</h1>
<p>
SQL и процедурно-ориентированные языки
[+]
Записаться
| Вам нравится?  Нравится 104 студентам
| Поделиться | Поддержать курс
| Скачать электронную книгу
Лекция 2: Основы SQL
A
| версия для печати
< Лекция 1 || Лекция 2: 12 || Лекция 3 >
Применение языка SQL

Подключение к СУБД

Перед тем как перейти к более подробному изучению операторов языка SQL, рассмотрим возможный сценарий работы пользователя с СУБД.

Первым шагом в любом случае следует выполнить подключение к СУБД. Например, CONNECT TO MyDB1 USER User1/Password1;.

Фраза TO специфицирует источник данных, с которым устанавливается соединение. Фраза USER определяет имя и пароль пользователя, который будет работать с базой данных.

Операторы и функции языка SQL не чувствительны к регистру, в отличие от строковых значений. Однако, как и в стандарте языка, SQL-операторы всегда будут обозначаться в лекциях заглавными буквами, а названия полей, таблиц и псевдонимов (алиасов) - строчными.

Перед началом работы с данными должны быть выполнены следующие действия:

    разработана модель базы данных и на ее основании создана схема базы данных - все взаимосвязанные таблицы;
    в каждую созданную таблицу должны быть введены данные.

Создание таблицы

Для создания таблицы используется оператор CREATE TABLE , имеющий в стандарте SQL92 следующее формальное описание:

CREATE [ [ { GLOBAL | LOCAL } ] TEMPORARY] 
    TABLE имя_таблицы
    ( { column | [table_constraint] } . , .. 
    [ ON COMMIT { DELETE | PRESERVE} ROWS ] );

column определяется как

имя_поля {domain | datatype [size]}
    [column_constraint:]
    [ DEFAULT default_value ]
    [ COLLATE collate_value ]

Фразы GLOBAL TEMPORARY или LOCAL TEMPORARY указывают на создание временной таблицы.

Фраза ON COMMIT может быть указана только для временных таблиц. По умолчанию для временных таблиц подразумевается фраза ON COMMIT DELETE ROWS.

После имени таблицы в круглых скобках через запятую указывается список полей (называемых также столбцами) и ограничений. Каждое поле имеет имя и тип (datatype). Тип может быть определен как любой допустимый тип языка SQL или как домен. Например, язык SQL допускает такие типы как : integer, char (число_символов), varchar (число_символов), int, smallint, float, date.

Фраза DEFAULT определяет значение по умолчанию. Это значение имеет более высокий приоритет, чем значение по умолчанию, указанное в домене (если вместо типа данных используется домен).

Ограничения для таблицы ( table_constraint ) и ограничения для столбца ( column_constraint ), называемые также ограничениями целостности, накладывают определенные условия на вводимые в таблицу данные.

Ограничения для столбца указываются непосредственно после описания столбца, а ограничения для таблицы - через запятую после описания любого столбца.

В стандарте SQL92 ограничения должны иметь имена, которые генерируются СУБД. В наиболее продвинутых БД, в частности Oracle, доступ к ограничениям возможен посредством служебных таблиц словаря базы данных и дополнительного набора команд языка SQL.

Ограничения для столбца могут указываться следующими фразами:

    NOT NULL - в любой добавляемой или изменяемой строке столбец всегда должен иметь значение, отличное от NULL .
    UNIQUE - все значения столбца должны быть уникальны.
    PRIMARY KEY - устанавливает один столбец как первичный ключ и одновременно подразумевает, что все значения столбца будут уникальны.
    CHECK ( condition ) - указываемое в скобках условие использует для сравнения значение столбца и возвращает TRUE, FALSE или UNKNOWN. Если при попытке выполнения SQL-оператора возвращаемое значение равно FALSE, то оператор выполнен не будет.
    REFERENCES table ( fields_list ) - ограничение требует совпадения значений столбцов данной таблицы с указанными столбцами родительской таблицы.

Ограничения для таблицы могут указываться следующими фразами:

    CHECK ( condition ) - указываемое в скобках условие использует для сравнения значение столбца и возвращает TRUE, FALSE или UNKNOWN. Если при попытке выполнения SQL-оператора возвращаемое значение равно FALSE, то оператор выполнен не будет.
    FOREIGN KEY ( fields_list ) - это ограничение по внешнему ключу аналогично ограничению REFERENCES для столбцов и гарантирует, что все значения, указанные во внешнем ключе, будут соответствовать значениям родительского ключа, обеспечивая ссылочную целостность. Следует отметить, что типы данных столбцов, используемых в этом ограничении, должны совпадать, а типы таблиц (постоянная базовая таблица, глобальная временная таблица, локальная временная таблица) родительского и внешнего ключа - соответствовать друг другу.

Стандарт SQL92 позволяет устанавливать режим контроля ограничений как перед выполнением каждого SQL-оператора, так и в конце текущей транзакции. В последнем случае допускается нарушение ограничения целостности внутри транзакции. Этот режим очень полезен для внесения данных в таблицы, связанные ограничением REFERENCES .
Определение ограничений для таблицы

Объявление ограничений имеет в стандарте SQL92 следующее формальное описание:

table_constraint определяется как

[ CONSTRAINT constraint_name ]
{ PRIMARY KEY (имя_поля .,:) }
| { UNIQUE (имя_поля .,:) } 
| { FOREIGN KEY (имя_поля .,:) }
{ REFERENCES имя_таблицы [(имя_поля .,:)] 
  [ref_specification] }
| { CHECK (condition) }
[[ NOT ] DEFFERABLE ]

column_constraint определяется как

[ CONSTRAINT constraint_name ]
{ NOT NULL } | { PRIMARY KEY } | UNIQUE
| { REFERENCES имя_таблицы [(имя_поля .,:) ]
    [ref_specification]}
| { CHECK (condition) }
| [ INITIALLY DEFFERED | INITIALLY IMMEDIATE ]
[[ NOT ] DEFFERABLE ]

ref_specification определяется как

[ MATCH {FULL | PARTIAL } ]
[ ON UPDATE
   { CASCADE | SET NULL | SET DEFAULT | 
     NO ACTION } ]
[ ON DELETE
   { CASCADE | SET NULL | SET DEFAULT | 
     NO ACTION } ]

Ссылочная спецификация ( ref_specification ) определяет для ограничений FOREIGN KEY и REFERENCES тип совпадения и действия, выполняемые при внесении изменений в родительский ключ. Совпадение может быть определено как MATCH FULL (полное совпадение) или MATCH PARTIAL (частичное совпадение).

При полном совпадении значения родительского и внешнего ключей должны полностью совпадать, или все значения внешнего ключа должны быть NULL.

При частичном совпадении некоторые значения внешнего ключа могут быть равны NULL и значения каждой строки внешнего ключа, отличные от NULL, должны совпадать со значениями родительского ключа.

Если тип совпадения не указан, то предполагается что любое значение внешнего ключа присутствует в родительском ключе, но при этом во внешнем ключе допускаются значения NULL (частично или полностью).

Рассмотрим таблицу tbl1, для которой определен родительский ключ как столбцы f2 и f3, и таблицу tbl2 с внешним ключом по столбцам c1 и c2. Если таблицы tbl1 tbl2 имеют следующие значения:</p>
    <div class="pages">
        <div class="page"><a href="lection2.php">1</a></div>
        <div class="page"><a href="lection2-2.php">2</a></div>
    </div>
    </div>
</body>
</html>