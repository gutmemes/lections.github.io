<?php 

include('index.php');
    
?>

    <div class="lections">
    <h1>Подзапросы</h1>
    <p>Язык SQL разрешает использовать в других операторах языка DML подзапросы, которые являются внутренними запросами, определяемыми оператором SELECT.

Подзапрос - очень мощное средство языка SQL. Он позволяет строить сложные иерархии запросов, многократно выполняемые в процессе построения результирующего набора или выполнения одного из операторов изменения данных ( DELETE , INSERT , UPDATE ).

Условно подзапросы иногда подразделяют на три типа, каждый из которых является сужением предыдущего:</p>
<ul>
    <li>абличный подзапрос, возвращающий набор строк и столбцов;</li>
    <li>подзапрос строки, возвращающий только одну строку, но, возможно, несколько столбцов (такие подзапросы часто используются во встроенном SQL);</li>
    <li>скалярный подзапрос, возвращающий значение одного столбца в одной строке.</li>
</ul>
<p>Подзапрос позволяет решать следующие задачи:</p>
<ul>
    
    <li>определять набор строк, добавляемый в таблицу на одно выполнение оператора INSERT ;</li>
    <li>определять данные, включаемые в представление, создаваемое оператором CREATE VIEW ;</li>
    <li>определять значения, модифицируемые оператором UPDATE ;</li>
    <li>указывать одно или несколько значений во фразах WHERE и HAVING оператора SELECT ;</li>
    <li>определять во фразе FROM таблицу как результат выполнения подзапроса ;</li>
    <li>применять коррелированные подзапросы. Подзапрос называется коррелированным, если запрос, содержащийся в предикате, имеет ссылку на значение из таблицы (внешней к данному запросу), которая проверяется посредством данного предиката.</li>

</ul>
<p>Hекоторые СУБД (например, СУБД Oracle) позволяют на основе подзапроса создавать новые таблицы с помощью оператора CREATE TABLE.

Простым примером использования подзапроса может служить следующий оператор:</p>
<pre><span class="keywords_red">SELECT * from tbl1 
         WHERE f2=(SELECT f2 FROM tbl2
                   WHERE f1=1);</span></pre>
                   <p>В данном операторе подзапрос всегда должен возвращать единственное значение, которое будет проверяться в предикате. Если подзапрос вернет более одного значения, то СУБД выдаст сообщение об ошибке выполнения SQL-оператора.

В случае если подзапрос не выберет ни одной строки, то предикат будет равен UNKNOWN, что большинством СУБД интерпретируется как FALSE.

Стандарт определяет запись предиката в форме "значение оператор подзапрос ". Однако некоторые СУБД также позволяют записывать предикат в форме, указывающей подзапрос слева от оператора сравнения.

Например:</p>
<pre><span class="keywords_red">SELECT * from tbl1 WHERE
    (SELECT f2 FROM tbl2 WHERE f1=1) = f2;</span></pre>
    <p>Очень часто с подзапросами используются агрегирующие функции, предоставляющие возможность сформулировать условие типа "больше, чем среднее по группе".

Например:</p>
<pre><span class="keywords_red">SELECT f1,f2,f3 FROM tbl1 
    WHERE f2> (SELECT AVG(f2) FROM tbl1);</span></pre>
    <p>Если результатом подзапроса становится группа строк (это случается всегда, когда условие не гарантирует уникальности значения проверяемого предикатом внутреннего запроса), то следует использовать оператор IN, осуществляющий выбор одного значения из указываемого множества.

Например:</p>
<pre><span class="keywords_red">SELECT * from tbl1 WHERE 
    f2 IN (SELECT f2 FROM tbl2 WHERE f1=1);</span></pre>
    <p>В этом случае предикат принимает значение TRUE, если хотя бы одно из значений, возвращаемых подзапросом, удовлетворяет условию.

Однако применение оператора IN имеет и некоторые смысловые недостатки: в запросе четко не определяется, сколько строк должны быть результатом выполнения запроса. При построении отношений для реальной модели данных это может приводить к некоторой неоднозначности и зависимости от самих данных. В противном случае, если модель данных предполагает в качестве постоянного результата подзапроса наличие только одной строки и, соответственно, использует оператор сравнения =, а структура данных позволяет ввод значений, когда в результате подзапроса будет более одной строки, то при использовании такого SQL-оператора в какой-то момент времени может проявиться ошибка.

Если в запросе участвуют более двух таблиц, то для большей наглядности имена полей иногда квалифицируют именами таблиц, указывая их через точку. Стандарт позволяет не квалифицировать имя поля именем таблицы в том случае, если не возникает неоднозначности (поле сначала ищется в таблице, указанной фразой FROM текущего запроса, затем внешнего запроса и т.д.).

Очень часто вместо записи оператора SELECT с использованием подзапроса можно применять соединения. Однако на практике большинство СУБД подзапросы выполняют более эффективно. Тем не менее, при проектировании комплекса программ с критичными требованиями по быстродействию, разработчик должен проанализировать план выполнения SQL-оператора для конкретной СУБД.

Наиболее продвинутые СУБД, такие как Oracle, предоставляют ряд SQL-операторов, позволяющих оценить производительность выполнения конкретного оператора языка SQL, а также определить уровень оптимизации, применяемый для данного оператора.

Подзапрос может быть указан как в предикате, определяемом фразой WHERE, так и в предикате по группам, определяемом фразой HAVING.

Например:</p>
<pre><span class="keywords_red">SELECT avg_f1, COUNT (f2) from tbl1
     GROUP BY avg_f1
     HAVING avg_f1 >(SELECT f1 FROM tbl1 
                     WHERE f3='a1');</span></pre>
    <div class="pages">
        <div class="page"><a href="lection5.php">1</a></div>
        <div class="page"><a href="lection5-2.php">2</a></div>
        <div class="page"><a href="lection5-3.php">3</a></div>
    </div>
    </div>
</body>
</html>